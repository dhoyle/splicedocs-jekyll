The Python Stored Procedure feature provides user with the ability to write stored procedure in Splice Machine using Python and a nearly 100% Python DB API 2.0 compliant interface to interact with the database.
This features is implemented by using Jython2.5.3 and zxJDBC.
Currently, Python stored procedure does not support using external libraries.

Dev Note:
Using Python stored Procedure to return ResultSets with large amount of rows can result in excessive usage of memory and CPU time.

How to create and run a Python Stored Procedure:

The process of create and run a Python Stored Procedure can be divided into two step:

1. The user then will write the Python script and install it. The entry point for user’s logic should be in the function ‘run’. The order of parameters of ‘run’ should match the order of parameters in the CREATE statement.
For more information on the Python script please refer to the section PythonScript.

#  The following example procedure returns a ResultSet containing at most k rows from SYS.SYSALIASES table, where k is the defined by the parameter limit.
CREATE PROCEDURE SPLICE.PYTHON_TEST(IN limit INT) PARAMETER STYLE JAVA READS SQL DATA LANGUAGE PYTHON DYNAMIC RESULT SETS 1 AS 'def run(lim, res):
    c = conn.cursor()
    # select alias and javaclassname columns from sys.sysaliases tables
    # return them as a ResultSet
    stmt = "select alias, javaclassname from sys.sysaliases {limit ?}"
    c.executemany(stmt,[lim])
    d = c.description
    result = c.fetchall()
    # construct the ResultSet and fill it into the ResultSet list res
    res[0] = factory.create([d,result])
    conn.commit()
    c.close()
    conn.close()';

2. After the creation of the Python Stored Procedure, the user can call it with the normal CALL SQL COMMAND:
CALL SPLICE.PYTHON_TEST(5);

Creating Python Stored Procedure Command:

The syntax for creating Python Stored Procedure is very similar to the one to create Java Stored Procedure.

The Changes are made to the Procedure Elements. Previously, the Procedure Elements is defined as follow:
{
    LANGUAGE { JAVA }
  | DeterministicCharacteristic
  | EXTERNAL NAME javaMethodName
  | PARAMETER STYLE parameterStyle
  | DYNAMIC RESULT SETS integer
  | sqlStatementType
}

Now it is:
{
    LANGUAGE { JAVA | PYTHON }
  | DeterministicCharacteristic
  | {EXTERNAL NAME javaMethodName | AS pythonScript}
  | PARAMETER STYLE parameterStyle
  | DYNAMIC RESULT SETS integer
  | sqlStatementType
}

When declare a Python stored procedure, the CREATE statement should:
1. Use PYTHON instead of JAVA for LANGUAGE.
2. Use AS followed by pythonScript instead of using EXTERNAL NAME followed by javaMethodName

* Inside the Python script, use Double Quotation Mark to wrap up a string instead of using Single Quotation Mark. Since using single quotation mark confuses the SQL parser. If single quotation mark must be used, replace it with two single quotation marks. These two single quotation marks will be resolved as one single quotation mark by the parser.

PythonScript

The user’s Stored Procedure logic should be written under the function ‘run’, and the method’s arguments’ order should be the same as they are in the CREATION COMMAND but arguments’ names in ‘run’ does not need to match the ones in the creation command.

If the stored procedure contains SQL then the user can use a global variable ‘conn’ to execute SQL statement. The global variable ‘conn’ provides a default connection.  Also, it needs to be noticed that, since the SQL statements in the stored procedure are executed via a nested connection, auto-commit cannot be turned on.

If the user returns k ResultSet, the user first need to define the function ‘run’ with extra k parameters appended at the end of the method’s parameters, where each of these k parameters represents a list ResultSet with size .

Then the user also needs to use the predefined function ‘factory’ to construct the ResultSet and fills the ResultSet list with it. ‘factory’ takes in two parameters -- description and result rows.

description: is a list of seven-item tuple describing describing each column that appears in the results of a query. The information is a seven-item tuple containing name, type code, display size, internal size, precision, scale and nullability

result rows: is a list of all the rows retrieved from the cursor of the result set. It can be retrieved from the cursor by calling ‘fetchall’.

The global variable ‘factory’ is com.splicemachine.derby.impl.sql.pyprocedure.PyStoredProcedureResultSetFactory. The implementation is contained in the following file:
splice_machine/src/main/java/com/splicemachine/derby/impl/sql/pyprocedure/PyStoredProcedureResultSetFactory.java

Implementation

The Python stored procedure is implemented based on the implementation of Java stored procedure. When create a Python stored procedure, the database compiles the Python script into bytecode which can be executed by Jython’s PythonInterpreter.

Upon the invocation of a Python Stored Procedure, a Java stored procedure is invoked internally. The compile bytecode is passed as a parameter into the Java stored procedure. Inside the Java stored procedure, the bytecode is executed by the Jython PythonInterpreter.

Thoughts on Improvement:
* Can I move the Java wrapper methods for Python stored procedure and Python user-defined function into System functions. In this way, the user does not need to register the Wrapper functions before running their Python scripts.
* The user might define multiple methods and global objects inside their scripts, and these objects can remain inside the PythonInterpreter. Need to clear the Interpreter upon releasing it. This will be done in the current branch.
* What new Exception messages should be added to make debugging easier
* Under which directory should the new files that are related to Python stored procedure be put?
* Right now, when returning a ResultSet, the user needs to use the PyStoredProcedureResultSetFactory to construct a new ResultSet. It needs to reconstruct each row in the ResultSet. Such operation can be expensive. I think there might be a way to create an Adapter for the zxJDBC’s cursor so that it can implements all the ResultSet’s interface.
* Currently,  the user uses two single quotation marks to enclose his Python script. This can be annoying as the user will need to replace his single quotation marks with double quotation marks or use two single quotation marks. A better approach is to use a similar syntax which is used by postgresql, where $$ is used to enclose the Python script.

NOTE:
DataType for Python stored procedure parameters:
Python stored procedure can take the same parameters as the Java stored procedure and cannot take CLOB, TEXT, BLOB as parameters.

Return DataType for Python Stored Procedure:
Python stored procedure only returns ResultSets just as the Java stored Procedure

Splice Machine Data Types reference: https://doc.splicemachine.com/sqlref_datatypes_intro.html

Jython & Java Type coercion:
Here is the table of Jython & Java Type coercion taken form Jython documentation

Java Type
Python Type
char
String(length of 1)
boolean
Integer(true = not zero)
byte, short, int, long
Integer
java.lang.String, byte[], char[]
String
java.lang.Class
JavaClass
Foo[]
Array(containing objects of class or subclass of Foo)
java.lang.Object
String
orb.python.core.PyObject
Unchanged
Foo
JavaInstance representing Java class Foo
