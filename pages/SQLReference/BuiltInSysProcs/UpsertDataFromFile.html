---
title: SYSCS_UTIL.SYSCS_UPSERT_DATA_FROM_FILE built-in system procedure
summary: Built-in system procedure that imports or updates data from a file into a table.
keywords: upserting, upsert data, upsert_data_from_file
toc: false
product: all
sidebar:  sqlref_sidebar
permalink: sqlref_sysprocs_upsertdata.html
folder: SQLReference/BuiltInSysProcs
---
	<section>
		<div class="TopicContent" data-swiftype-index="true">
            <h1 id="BuiltInSysProcs.UpsertDataFromFile">SYSCS_UTIL.UPSERT_DATA_FROM_FILE</h1>
            <p>The <span class="CodeFont">SYSCS_UTIL.UPSERT_DATA_FROM_FILE</span> system procedure
			updates or inserts data from a file to a subset of columns in a table.  You choose the subset of columns
			by specifying insert columns in your <span class="CodeFont">insertColumnList</span> parameter. </p>
            <p>The syntax and usage of this procedure is almost identical to the syntax and usage of the <span class="CodeFont"><a href="sqlref_sysprocs_importdata.html">SYSCS_UTIL.IMPORT_DATA</a></span> system procedure, except that <span class="CodeFont">SYSCS_UTIL.UPSERT_DATA_FROM_FILE</span> first determines if the database already contains a record that matches an incoming record:</p>
            <ul>
                <li>If a matching record is found in the database, that record is updated with column values from the incoming record.</li>
                <li>If no matching record is found in the database, the incoming record is added to the database as a new record, exactly as it would be if had you called <span class="CodeFont"><a href="sqlref_sysprocs_importdata.html">SYSCS_UTIL.IMPORT_DATA</a></span>.</li>
            </ul>
			<div class="noteIcon">Splice Machine also provides a variant of this procedure that also imports new records and updates existing records in a table: <span class="CodeFont"><a href="sqlref_sysprocs_mergedata.html">SYSCS_UTIL.MERGE_DATA_FROM_FILE</a></span> operates similarly, but applies different semantics when updating existing records with generated values. For more information, see the <a href="#ImportColVals">Inserting and Updating Column Values When Importing</a> section below.</div>
            <p>After a successful import completes, a simple report displays, showing how many files were imported, and how many record imports succeeded or failed.</p>
            <div class="noteNote">
				<p>On a cluster, the files to be imported <span class="BoldFont">MUST be on S3, HDFS (or MapR-FS)</span>, as must the <span class="CodeFont">badRecordDirectory</span> directory. If you're using our Database Service product, files can only be imported from S3.</p>
				<p>In addition, the files must be readable by the <span class="CodeFont">hbase</span> user, and the <span class="CodeFont">badRecordDirectory</span> directory must be writable by the hbase user, either by setting the user explicity, or by opening up the permissions; for example:</p>
				<div class="preWrapper"><pre class="ShellCommand">sudo -su hdfs hadoop fs -chmod 777 /badRecordDirectory</pre></div>
			</div>
            <h2>Syntax</h2>
            <div class="fcnWrapperWide"><pre class="FcnSyntax" xml:space="preserve">call SYSCS_UTIL.UPSERT_DATA_FROM_FILE (
               <span class="ItalicFont">schemaName</span>,
               <span class="ItalicFont">tableName</span>,
               <span class="ItalicFont">insertColumnList</span><span class="CodeFont"> | null</span>,
               <span class="ItalicFont">fileOrDirectoryName</span>,
               <span class="ItalicFont">columnDelimiter</span><span class="CodeFont"> | null</span>,
               <span class="ItalicFont">characterDelimiter</span><span class="CodeFont"> | null</span>,
               <span class="ItalicFont">timestampFormat</span><span class="CodeFont"> | null</span>,
               <span class="ItalicFont">dateFormat</span><span class="CodeFont"> | null</span>,
               <span class="ItalicFont">timeFormat</span><span class="CodeFont"> | null</span>,
               <span class="ItalicFont">badRecordsAllowed</span>,
               <span class="ItalicFont">badRecordDirectory</span><span class="CodeFont"> | null</span>,
               <span class="ItalicFont">oneLineRecords</span><span class="CodeFont"> | null</span>,
               <span class="ItalicFont">charset</span><span class="CodeFont"> | null</span>
);</pre>
            </div>
{% include splice_snippets/importparamlist.html %}
            <h2>Results</h2>
            <p><span class="CodeFont">SYSCS_UTIL.UPSERT_DATA_FROM_FILE</span> displays a summary of the import process results that looks like this:</p>
            <div class="preWrapperWide"><pre class="Example" xml:space="preserve">
rowsImported   |failedRows   |files   |dataSize   |failedLog<br />-------------------------------------------------------------
94             |0            |1       |4720       |NONE<br /></pre>
            </div>
            <p class="spaceAbove">This procedure also logs rejected record activity into <span class="CodeFont">.bad</span> files in the <span class="CodeFont">badRecordDirectory</span> directory; one file for each imported file. </p>
            <div class="noteNote">After importing a large amount of data into a table, it is useful to run a full compaction on table; see the <span class="CodeFont"><a href="sqlref_sysprocs_compacttable.html">SYSCS_UTIL.SYSCS_PERFORM_MAJOR_COMPACTION_ON_TABLE</a></span> system procedure.</div>
            <h3>Importing a Subset of Data From a File</h3>
            <p>When you import data from a file into a table, all of the data in the file is not necessarily imported. This can happen in either of these circumstances:</p>
            <ul>
                <li>If the table into which you're importing contains less columns than does the data file, the "extra" columns of data are ignored. </li>
                <li>If the <span class="CodeFont">insertColumnList</span> in your import call specifies only a subset of the columns in the data file. </li>
            </ul>
            <p>Please see the <a href="#ImportColVals">Inserting and Updating Column Values When Importing Data</a>section below for detailed information about how table column values are updated when importing data with our different procedures.</p>
            <h2>Usage</h2>
            <p>This procedure will only work correctly if the table into which you are inserting/updating data has primary keys.</p>
            <p>When you generate the input file, it must:</p>
            <ul>
                <li>contain the columns to be changed</li>
                <li>contain all <span class="CodeFont">NON_NULL</span> columns</li>
            </ul>
            <h2>Record Import Failure Reasons</h2>
            <p>When upserting data from a file, the input file you generate must contain:</p>
            <ul>
                <li>the columns to be changed</li>
                <li>all <span class="CodeFont">NON_NULL</span> columns</li>
            </ul>
            <p>Typical reasons for a row (record) import to fail include:</p>
            <ul>
                <li>Improper data expected for a column.</li>
                <li>Improper number of columns of data.</li>
                <li>
                    <p>A primary key violation: <a href="#"><span class="CodeFont">SYSCS_UTIL.UPSERT_DATA_FROM_FILE</span></a> will only work correctly if the table into which you are inserting/updating has primary keys. </p>
                </li>
            </ul>
{% include splice_snippets/importcolvals.html %}
            <h2 id="TimestampFormats">About Timestamp Formats</h2>
{% include splice_snippets/importtimestampformats.html %}
            <p>Please see <span class="ItalicFont"><a href="developers_fundamentals_dates.html">Working With Date and Time Values</a></span> in the <span class="ItalicFont">Developer's Guide</span> for information working with timestamps, dates, and times.</p>
            <h2 id="Examples">Examples</h2>
            <p>The examples in this section illustrate using different timestamp formats and different string delimiter characters.</p>
            <h3>Example 1: Specifying a timestamp format for an entire table</h3>
            <p>Use a single timestamp format for the entire table by explicitly specifying a single <span class="CodeFont">timeStampFormat</span>.</p>
            <div class="preWrapper"><pre class="Example" xml:space="preserve">Mike,2013-04-21 09:21:24.98-05
Mike,2013-04-21 09:15:32.78-04
Mike,2013-03-23 09:45:00.68-05</pre>
            </div>
            <p>You can then import the data with the following call:</p>
            <div class="preWrapper"><pre class="Example" xml:space="preserve">call SYSCS_UTIL.UPSERT_DATA_FROM_FILE('app','tabx','c1,c2',
	'/path/to/ts3.csv',
	',', '''',
	'yyyy-MM-dd HH:mm:ss.SSZ',
	null, null, 0, null, true, null);</pre>
            </div>
            <p>Note that for any import use case shown above, the time shown in the imported table depends on the timezone setting in the server timestamp. In other words, given the same csv file, if imported on different servers with timestamps set to different time zones, the value in the table shown will be different. Additionally, daylight savings time may account for a 1-hour difference if timezone is specified.</p>
            <h3>Example 2: Importing strings with embedded special characters </h3>
            <p>This example imports a csv file that includes newline (<span class="CodeFont">Ctrl-M</span>) characters in some of the input strings. We use the default double-quote as our character delimiter to import data such as the following:</p>
            <div class="preWrapperWide"><pre class="Example" xml:space="preserve">1,This field is one line,Able
2,"This field has two lines
This is the second line of the field",Baker
3,This field is also just one line,Charlie
</pre>
            </div>
            <p>We then use the following call to import the data:</p>
            <div class="preWrapperWide"><pre class="Example" xml:space="preserve">SYSCS_UTIL.UPSERT_DATA_FROM_FILE('SPLICE','MYTABLE',null,'data.csv','\t',null,null,null,null,0,'BAD', false, null);
</pre>
            </div>
            <p>We can also explicitly specify double quotes (or any other character) as our delimiter character for strings:</p>
            <div class="preWrapperWide"><pre class="Example" xml:space="preserve">SYSCS_UTIL.UPSERT_DATA_FROM_FILE('SPLICE','MYTABLE',null,'data.csv','\t','"',null,null,null,0,'BAD', false, null);</pre>
            </div>
            <h3>Example 3: Using single quotes to delimit strings</h3>
            <p>This example performs the same import as the previous example, simply substituting single quotes for double quotes as the character delimiter in the input:</p>
            <div class="preWrapperWide"><pre class="Example" xml:space="preserve">1,This field is one line,Able
2,'This field has two lines
This is the second line of the field',Baker
3,This field is also just one line,Charlie
</pre>
            </div>
            <p>Note that you must escape single quotes in SQL, which means that you actually define the character delimiter parameter with four single quotes, as follow</p>
            <div class="preWrapperWide"><pre class="Example" xml:space="preserve">SYSCS_UTIL.UPSERT_DATA_FROM_FILE('SPLICE','MYTABLE',null,'data.csv','\t','''',null,null,null,0,'BAD', false, null);
</pre>
            </div>
            <h2>See Also</h2>
            <ul>
				<li><a href="tutorials_ingest_importing.html">Our Importing Data Tutorial</a></li>
                <li><a href="sqlref_sysprocs_importdata.html"><span class="CodeFont">SYSCS_UTIL.IMPORT_DATA</span></a>
                </li>
                <li><a href="sqlref_sysprocs_importdata.html"><span class="CodeFont">SYSCS_UTIL.MERGE_DATA_FROM_FILE</span></a>
				</li>
            </ul>
        </div>
	</section>
