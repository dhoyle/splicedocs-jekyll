---
title: generated-column-spec
summary: Describes the syntax for generated columns, the value of which is automatically incremented and assigned to each record that is created.
keywords: generated column, generated always, autoincrement, auto increment, generated by default, by default, as identity, identity, start with, increment by, unique
toc: false
product: all
sidebar:  sqlref_sidebar
permalink: sqlref_statements_generatedcolspec.html
folder: SQLReference/Statements
---
	<section>
		<div class="TopicContent" data-swiftype-index="true">
            <h1 id="Statements.GeneratedColumnSpec">generated-column-spec</h1>
            <p>A&#160;generated column is one whose value is defined by an expression, typically involving values from other columns in the same table. The value of a generated column is automatically updated whenever there's a change in the value of any column upon which the expression depends.</p>
            <div class="fcnWrapperWide"><pre class="FcnSyntax">[ GENERATED { ALWAYS | BY DEFAULT } AS IDENTITY
[ ( START WITH IntegerConstant
[ ,INCREMENT BY IntegerConstant] ) ]  ]  ]
</pre>
            </div>
            <div class="paramList">
                <p class="paramName">{ALWAYS&#160;|&#160;BY&#160;DEFAULT}&#160;AS&#160;IDENTITY</p>
                <p class="paramDefnFirst">A table can have at most one identity column. See the <a href="#IdentityAttributes">Identity Column Attributes</a> section below for more information about identity columns.Splice Machine supports two kinds of identity columns:
				</p>
                <div class="paramListNested">
                    <p class="paramName"><code>GENERATED ALWAYS</code>
                    </p>
                    <p class="paramDefnFirst">An identity column that is <code>GENERATED ALWAYS</code> will increment the default value on every insertion and will store the incremented value into the column. Unlike other defaults, you cannot insert a value directly into or update an identity column that is <code>GENERATED ALWAYS</code>. Instead, either specify the <code>DEFAULT</code> keyword when inserting into the identity column, or leave the identity column out of the insertion column list altogether. For example:</p>
                        <div class="preWrapperWide"><pre class="Example" xml:space="preserve">create table greetings
  (i int generated always as identity, ch char(50));
insert into greetings values (DEFAULT, 'hello');
insert into greetings(ch) values ('bonjour');</pre>
                        </div>
                    <p class="paramDefn">Automatically generated values in a <code>GENERATED ALWAYS</code> identity column are unique. Creating an identity column does not create an index on the column.</p>
                    <p class="paramName"><code>GENERATED&#160;BY DEFAULT</code>
                    </p>
                    <p class="paramDefnFirst">An identity column that is <code>GENERATED BY DEFAULT</code> will only increment and use the default value on insertions when no explicit value is given. Unlike <code>GENERATED ALWAYS</code> columns, you can specify a particular value in an insertion statement to be used instead of the generated default value.</p>
                    <p class="paramDefn">To use the generated default, either specify the <code>DEFAULT</code> keyword when inserting into the identity column, or just leave the identity column out of the insertion column list. To specify a value, included it in the insertion statement. For example:</p>
                        <div class="preWrapperWide"><pre class="Example" xml:space="preserve">create table greetings
(i int generated by default as identity, ch char(50));
&#160;&#160;&#160;&#160;&#160;&#160;&#160;-- specify value "1":
insert into greetings values (1, 'hi');
       -- use generated default
insert into greetings values (DEFAULT, 'salut');
&#160;&#160;&#160;&#160;&#160;&#160;&#160;-- use generated default
insert into greetings(ch) values ('bonjour'); </pre>
                        </div>
                    <p class="paramDefn">Note that unlike a <code>GENERATED ALWAYS</code> column, a <code>GENERATED BY DEFAULT</code> column does not guarantee uniqueness. Thus, in the above example, the <code>hi</code> and <code>salut</code> rows will both have an identity value of "1", because the generated column starts at <code>1</code> and the user-specified value was also <code>1</code>. You can prevent duplication by specifying a <code>START&#160;WITH</code>&#160;value, and using a primary key or unique constraint on the identity column</p>
                </div>
                <p class="paramName">START&#160;WITH&#160;IntegerConstant</p>
                <p class="paramDefnFirst">The first identity value that Splice Machine should assign.</p>
                <p class="paramName">INCREMENT&#160;BY&#160;IntegerConstant</p>
                <p class="paramDefnFirst">The amount by which to increment the identity value each time one is assigned.</p>
            </div>
            <h2 id="IdentityAttributes">Identity Column Attributes</h2>
            <p>A table can have at most one identity column.</p>
            <p>For <code>SMALLINT</code>, <code>INT</code>, and <code>BIGINT</code> columns with identity attributes, Splice Machine automatically assigns increasing integer values to the column. Identity column attributes behave like other defaults in that when an insert statement does not specify a value for the column, Splice Machine automatically provides the value. However, the value is not a constant; Splice Machine automatically increments the default value at insertion time.</p>
            <p>The <code>IDENTITY</code> keyword can only be specified if the data type associated with the column is one of the following exact integer types.</p>
            <ul>
                <li><code><a href="sqlref_builtinfcns_smallint.html">SMALLINT</a></code>
                </li>
                <li><code><a href="sqlref_builtinfcns_integer.html">INT</a></code>
                </li>
                <li><code><a href="sqlref_builtinfcns_bigint.html">BIGINT</a></code>
                </li>
            </ul>
            <p>By default, the initial value of an identity column is 1, and the amount of the increment is 1. You can specify any positive integer value for both the initial value and the interval amount when you define the column with the key words START WITH and INCREMENT BY. Splice Machine increments the value with each insert. A value of 0 raises a statement exception. </p>
            <p>The maximum and minimum values allowed in identity columns are determined by the data type of the column. Attempting to insert a value outside the range of values supported by the data type raises an exception. The following table shows the supported ranges.</p>
            <table summary="Minimum and maximum values allowed in identity columns">
                <col />
                <col />
                <col />
                <thead>
                    <tr>
                        <th>Data Type</th>
                        <th>Maximum Value</th>
                        <th>Minimum Value</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><code>SMALLINT</code>
                        </td>
                        <td><code>32767</code> (<em>java.lang.Short.MAX_VALUE</em>)</td>
                        <td><code>-32768</code> (<em>java.lang.Short.MIN_VALUE</em>)</td>
                    </tr>
                    <tr>
                        <td><code>INT</code>
                        </td>
                        <td><code>2147483647</code> (<em>java.lang.Integer.MAX_VALUE</em>)</td>
                        <td>-2147483648 (<em>java.lang.Integer.MIN_VALUE</em>)</td>
                    </tr>
                    <tr>
                        <td><code>BIGINT</code>
                        </td>
                        <td><code>9223372036854775807</code> (<em>java.lang.Long.MAX_VALUE</em>)</td>
                        <td>-9223372036854775808 (<em>java.lang.Long.MIN_VALUE</em>)</td>
                    </tr>
                </tbody>
            </table>
            <p>Automatically generated values in an identity column are unique. Use a primary key or unique constraint on a column to guarantee uniqueness. Creating an identity column <em>does not</em> create an index on the column.</p>
            <p class="noteNote">Specify the schema, table, and column name using the same case as those names are stored in the system tables--that is, all upper case unless you used delimited identifiers when creating those database objects.</p>
            <h2>Using Generated Columns</h2>
            <p>Splice Machine keeps track of the last increment value for a column in a cache. It also stores the value of what the next increment value will be for the column on disk in the <code>AUTOINCREMENTVALUE</code> column of the <code>SYS.SYSCOLUMNS</code> system table. Rolling back a transaction does not undo this value, and thus rolled-back transactions can leave "gaps" in the values automatically inserted into an identity column. Splice Machine behaves this way to avoid locking a row in <code>SYS.SYSCOLUMNS</code> for the duration of a transaction and keeping concurrency high. </p>
            <p>When an insert happens within a triggered-SQL-statement, the value inserted by the triggered-SQL-statement into the identity column is available from <em>ConnectionInfo</em> only within the trigger code. The trigger code is also able to see the value inserted by the statement that caused the trigger to fire. However, the statement that caused the trigger to fire is not able to see the value inserted by the triggered-SQL-statement into the identity column. Likewise, triggers can be nested (or recursive).</p>
            <p>An SQL statement can cause trigger T1 to fire. T1 in turn executes an SQL statement that causes trigger T2 to fire. If both T1 and T2 insert rows into a table that cause Splice Machine to insert into an identity column, trigger T1 cannot see the value caused by T2's insert, but T2 can see the value caused by T1's insert. Each nesting level can see increment values generated by itself and previous nesting levels, all the way to the top-level SQL statement that initiated the recursive triggers. You can only have 16 levels of trigger recursion.</p>
            <h2>Examples</h2>
            <div class="preWrapperWide"><pre class="Example" xml:space="preserve">create table greetings
  (i int generated by default
    as identity (START WITH 2, INCREMENT BY 1),
  ch char(50));
 -- specify value "1":
insert into greetings values (1, 'hi');
 -- use generated default
insert into greetings values (DEFAULT, 'salut');
 -- use generated default
insert into greetings(ch) values ('bonjour);
drop table if exists words;

splice&gt; CREATE TABLE WORDS(WORD VARCHAR(20), UWORD GENERATED ALWAYS AS (UPPER(WORD)));
0 rows inserted/updated/deleted
splice&gt; CREATE INDEX IDX_UWORD ON WORDS(UWORD);
0 rows inserted/updated/deleted
splice&gt; INSERT INTO WORDS(WORD) VALUES 'chocolate', 'Coca-Cola', 'hamburger', 'carrot';
4 rows inserted/updated/deleted
splice&gt; select * from words;
WORD                |UWORD
--------------------------------------------------------------------------------
chocolate           |CHOCOLATE
Coca-Cola           |COCA-COLA
hamburger           |HAMBURGER
carrot              |CARROT

4 rows selected
splice&gt; select upper(word) from words;
1
--------------------------------------------------------------------------------
CHOCOLATE
COCA-COLA
HAMBURGER
CARROT

4 rows selected
splice&gt; drop table if exists t;
0 rows inserted/updated/deleted
WARNING 42Y55: 'DROP TABLE' cannot be performed on 'T' because it does not exist.
splice&gt; CREATE TABLE T(COL1 INT, COL2 INT, COL3 GENERATED ALWAYS AS (COL1+COL2));
0 rows inserted/updated/deleted
splice&gt; INSERT INTO T (COL1, COL2) VALUES (1,2), (3,4), (5,6);
3 rows inserted/updated/deleted
splice&gt; select * from t;
COL1       |COL2       |COL3
--------------------------------------------------------------------------------
1          |2          |3
3          |4          |7
5          |6          |11

3 rows selected
splice&gt; UPDATE T SET COL2 = 100 WHERE COL1 = 1;
1 row inserted/updated/deleted
splice&gt; select * from t;
COL1       |COL2       |COL3
--------------------------------------------------------------------------------
1          |100        |101
3          |4          |7
5          |6          |11

3 rows selected</pre>
            </div>
        </div>
	</section>
