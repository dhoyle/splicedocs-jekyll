---
title: Splice Machine Window Functions
summary: A quick summary of window functions, as implemented in Splice Machine SQL.
keywords: window functions, grouping, partition, default value
toc: false
product: all
sidebar: developers_sidebar
permalink: developers_fundamentals_windowfcns.html
folder: Developers/Fundamentals
---
	<section>
		<div class="TopicContent" data-swiftype-index="true">
            <h1>Splice Machine Window Functions</h1>
            <p>An SQL&#160;<em>window function</em> performs a calculation across a set of table rows that are related to the current row, either by proximity in the table, or by the value of a specific column or set of columns; these columns are known as the <em>partition</em>.</p>
            <p>This topic provides a very quick summary of window functions, as implemented in Splice Machine. For more general information about SQL&#160;window functions, we recommending visiting some of the sources listed in the <a href="#ForMoreInfo" class="selected">Additional Information</a> section at the end of this topic. </p>
            <p>Here's a quick example of using a window function to operate on the following table:</p>
            <div class="indented">
                <table>
                    <col />
                    <col />
                    <col />
                    <thead>
                        <tr>
                            <th>OrderID</th>
                            <th>CustomerID</th>
                            <th>Amount</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>123</td>
                            <td>1</td>
                            <td>100</td>
                        </tr>
                        <tr>
                            <td>
                            144
                        </td>
                            <td>1</td>
                            <td>250</td>
                        </tr>
                        <tr>
                            <td>167</td>
                            <td>1</td>
                            <td>150</td>
                        </tr>
                        <tr>
                            <td>
                            202
                        </td>
                            <td>
                            1
                        </td>
                            <td>250</td>
                        </tr>
                        <tr>
                            <td>209</td>
                            <td>1</td>
                            <td>325</td>
                        </tr>
                        <tr>
                            <td>
                            224
                        </td>
                            <td>
                            1
                        </td>
                            <td>125</td>
                        </tr>
                        <tr>
                            <td>66</td>
                            <td>2</td>
                            <td>100</td>
                        </tr>
                        <tr>
                            <td>
                            94
                        </td>
                            <td>
                            2
                        </td>
                            <td>200</td>
                        </tr>
                        <tr>
                            <td>127</td>
                            <td>2</td>
                            <td>300</td>
                        </tr>
                        <tr>
                            <td>
                            444
                        </td>
                            <td>
                            2
                        </td>
                            <td>400</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <p>This query will find the first Order ID&#160;for each specified Customer ID in the above table:</p><pre class="Example" xml:space="preserve">SELECT&#160;OrderID, CustomerID,
    FIRST_VALUE(OrderID)&#160;OVER&#160;(
        PARTITION&#160;BY&#160;CustomerID
        ORDER&#160;BY&#160;OrderID
        ROWS&#160;BETWEEN&#160;UNBOUNDED&#160;PRECEDING AND&#160;CURRENT&#160;ROW&#160;)
AS&#160;FirstOrderID
FROM&#160;ORDERS
WHERE&#160;CustomerID IN&#160;(1,2);</pre>
            <p>This works by partitioning (grouping)&#160;the selected rows by CustomerID, ordering them for purposes of applying the function to the rows in the partition, and then using the <code>FIRST_VALUE</code>&#160;window function to evaluate the OrderID&#160;values in each partition and find the first value in each. The results for our sample table are:</p>
            <div class="indented">
                <table summary="Sample table results from a FIRST_VALUE operation.">
                    <col />
                    <col />
                    <col />
                    <thead>
                        <tr>
                            <th>OrderID</th>
                            <th>CustomerID</th>
                            <th>FirstOrderID</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>123</td>
                            <td>1</td>
                            <td>123</td>
                        </tr>
                        <tr>
                            <td>144</td>
                            <td>1</td>
                            <td>123</td>
                        </tr>
                        <tr>
                            <td>167</td>
                            <td>1</td>
                            <td>123</td>
                        </tr>
                        <tr>
                            <td>202</td>
                            <td>1</td>
                            <td>123</td>
                        </tr>
                        <tr>
                            <td>209</td>
                            <td>1</td>
                            <td>123</td>
                        </tr>
                        <tr>
                            <td>224</td>
                            <td>1</td>
                            <td>123</td>
                        </tr>
                        <tr>
                            <td>66</td>
                            <td>2</td>
                            <td>66</td>
                        </tr>
                        <tr>
                            <td>94</td>
                            <td>2</td>
                            <td>66</td>
                        </tr>
                        <tr>
                            <td>127</td>
                            <td>2</td>
                            <td>66</td>
                        </tr>
                        <tr>
                            <td>444</td>
                            <td>2</td>
                            <td>66</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <p>See the <a href="#Window2" class="selected">Window Frames</a> section below for a further explanation of this query.</p>
            <h2>About Window Functions</h2>
            <p>Window functions:</p>
            <ul>
                <li>Operate on a window, or set of rows. The rows considered by a window function are produced by the query's <code>FROM</code> clause as filtered by its <code>WHERE</code>, <code>GROUP BY</code>, and <code>HAVING</code> clauses, if any. This means that any row that doesn't meet the <code>WHERE</code>&#160;condition is not seen by a window function.</li>
                <li> Are similar to aggregate functions, except that a window function does not group rows into a single output row. Instead, a window function returns a value for every row in the window. This is sometimes referred to as tuple-based aggregation.</li>
                <li>The values are calculated from the set of rows in the window.</li>
                <li>Always contain an <code>OVER</code> clause, which determines how the rows of the query are divided and sequenced for processing by the window function. </li>
                <li>The <code>OVER</code>&#160;clause can contain a <code>PARTITION</code>&#160;clause that specifies the set of rows in the table that form the window, relative to the current row.</li>
                <li>
                    <p>The <code>OVER</code>&#160;clause can contain an optional <code>ORDER&#160;BY</code>&#160;clause that specifies in which order rows are processed by the window function. This <code>ORDER&#160;BY</code>&#160;clause is independent of the <code>ORDER&#160;BY</code>&#160;clause that specifies the order in which rows are output. </p>
                    <p>Note that the <a href="sqlref_builtinfcns_rownumber.html">ROW&#160;NUMBER</a> <strong>must contain</strong> an <code>ORDER&#160;BY</code>&#160;clause.</p>
                </li>
                <li>The <code>OVER</code>&#160;clause can also contain an optional <em>frame clause</em> that further restricts which of the rows in the partition are sent to the function for evaluation.</li>
            </ul>
            <h3>About Windows, Partitions, and Frames</h3>
            <p>Using window functions can seem complicated because they involve a number of overlapping terms, including <em>window</em>, <em>sliding window</em>, <em>partition</em>, <em>set</em>, and <em>window frame</em>. An additional complication is that window frames can be specified using either <em>rows</em> or <em>ranges</em>.</p>
            <p>Let's start with basic terminology definitions:</p>
            <table summary="Window functions terminology glossary.">
                <col />
                <col />
                <thead>
                    <tr>
                        <th>Terms</th>
                        <th>Description</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td class="ItalicFont">window function</td>
                        <td>A function that operates on a set of rows and produces output for each row.</td>
                    </tr>
                    <tr>
                        <td class="ItalicFont">window partition</td>
                        <td>
                            <p>The grouping of rows within a table.</p>
                            <p>Note that window partitions retains the rows, unlike aggregates, </p>
                        </td>
                    </tr>
                    <tr>
                        <td class="ItalicFont">window ordering</td>
                        <td>The sequence of rows within each partition; this is the order in which the rows are passed to the window function for evaluation.</td>
                    </tr>
                    <tr>
                        <td class="ItalicFont">window frame</td>
                        <td>A frame of rows within a window partition, relative to the current row. The window frame is used to further restrict the set of rows operated on by a function, and is sometimes referred to as the <em>row or range</em> clause.</td>
                    </tr>
                    <tr>
                        <td class="ItalicFont">OVER&#160;clause</td>
                        <td>
                            <p>This is the clause used to define how the rows of the table are divided, or partitioned, for processing by the window function. It also orders the rows within the partition.</p>
                            <p>See the <a href="#The" class="selected">The OVER&#160;Clause</a> section below for more information.</p>
                        </td>
                    </tr>
                    <tr>
                        <td class="ItalicFont">partitioning clause</td>
                        <td>
                            <p>An optional part of an <code>OVER</code>&#160;clause that divides the rows into partitions, similar to using the <code>GROUP&#160;BY</code>&#160;clause. The default partition is all rows in the table, though window functions are generally calculated over a partition.</p>
                            <p>See the <a href="#Window" class="selected">The Partition Clause</a> section below for more information.</p>
                        </td>
                    </tr>
                    <tr>
                        <td class="ItalicFont">ordering clause</td>
                        <td>
                            <p>Defines the ordering of rows within each partition. </p>
                            <p>See the <a href="#The2" class="selected">The Order Clause</a> section below for more information.</p>
                        </td>
                    </tr>
                    <tr>
                        <td class="ItalicFont">frame clause</td>
                        <td>
                            <p>Further refines the set of rows when you include an <code>ORDER&#160;BY</code>&#160;clause in your window function specification, by allowing you to include or exclude rows or values within the ordering. </p>
                            <p>See the <a href="#Window2" class="selected">The Frame Clause</a> section below for examples and more information.</p>
                        </td>
                    </tr>
                </tbody>
            </table>
            <h3 id="The">The OVER&#160;Clause</h3>
            <p>A window function alway contains an <code>OVER</code> clause, which determines how the rows of the query are divided, or partitioned, for processing by the window function.</p>
            <div class="fcnWrapperWide"><pre class="FcnSyntax" xml:space="preserve">expression OVER(&#160;
     [<em><a href="#Window" class="selected">partitionClause</a></em>]
     [<em><a href="#The2" class="selected">orderClause</a></em>]
     [<em><a href="#Window2" class="selected">frameClause</a></em>] );
 </pre>
            </div>
            <div class="paramList">
                <p class="paramName">expression</p>
                <p class="paramDefnFirst">Any value expression that does not itself contain window function calls.</p>
            </div>
            <p class="noteNote">When you use an <a href="sqlref_builtinfcns_windowfcnsintro.html">aggregate function</a> such as <code>AVG</code>&#160;with an <code>OVER</code>&#160;clause, the aggregated value is computed per partition.</p>
            <h3 id="Window">The Partition Clause</h3>
            <p>The partition clause, which is optional, specifies how the window function is broken down over groups, in the same way that <code>GROUP&#160;BY</code>&#160;specifies groupings for regular aggregate functions. Some example partitions are:</p>
            <ul>
                <li>departments within an organization</li>
                <li>regions within a geographic area</li>
                <li>quarters within years for sales</li>
            </ul>
            <p class="noteNote">If you omit the partition clause, the default partition, which contains all rows in the table, is used.However, since window functions are used to perform calculations over subsets (partitions) of rows in a table, you generally should specify a partition clause.</p>
            <h4>Syntax</h4>
            <div class="fcnWrapperWide"><pre class="FcnSyntax" xml:space="preserve">PARTITION&#160;BY&#160;<em>expression</em> [, ...]</pre>
            </div>
            <div class="paramListNested">
                <p class="paramName">expression [,...]</p>
                <p class="paramDefnFirst">A list of expressions that define the partitioning.</p>
            </div>
            <p>If you omit this clause, there is one partition that contains all rows in the entire table.</p>
            <p>Here's a simple example of using the partition clause to compute the average order amount per customer:</p><pre class="Example" xml:space="preserve">SELECT&#160;OrderID, CustomerID, Amount,
    Avg(Amount)&#160;OVER&#160;(
        PARTITION&#160;BY&#160;CustomerID
        ORDER&#160;BY&#160;OrderID
        ROWS&#160;BETWEEN&#160;UNBOUNDED&#160;PRECEDING AND&#160;CURRENT&#160;ROW&#160;)
AS&#160;AverageOrderAmt FROM&#160;ORDERS
WHERE&#160;CustomerID IN&#160;(1,2);</pre>
            <div class="indented">
                <table summary="Results table from an AVG operation.">
                    <col />
                    <col />
                    <col />
                    <col />
                    <thead>
                        <tr>
                            <th>OrderID</th>
                            <th>CustomerID</th>
                            <th>Amount</th>
                            <th>AverageOrderAmt</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>123</td>
                            <td>1</td>
                            <td>100</td>
                            <td>200</td>
                        </tr>
                        <tr>
                            <td>144</td>
                            <td>1</td>
                            <td>250</td>
                            <td>200</td>
                        </tr>
                        <tr>
                            <td>167</td>
                            <td>1</td>
                            <td>150</td>
                            <td>200</td>
                        </tr>
                        <tr>
                            <td>202</td>
                            <td>1</td>
                            <td>250</td>
                            <td>200</td>
                        </tr>
                        <tr>
                            <td>209</td>
                            <td>1</td>
                            <td>325</td>
                            <td>200</td>
                        </tr>
                        <tr>
                            <td>224</td>
                            <td>1</td>
                            <td>125</td>
                            <td>200</td>
                        </tr>
                        <tr>
                            <td>66</td>
                            <td>2</td>
                            <td>100</td>
                            <td>250</td>
                        </tr>
                        <tr>
                            <td>94</td>
                            <td>2</td>
                            <td>200</td>
                            <td>250</td>
                        </tr>
                        <tr>
                            <td>127</td>
                            <td>2</td>
                            <td>300</td>
                            <td>250</td>
                        </tr>
                        <tr>
                            <td>444</td>
                            <td>2</td>
                            <td>400</td>
                            <td>250</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <h3 id="The2">The Order Clause</h3>
            <p>You can also control the order in which rows are processed by window functions using <code>ORDER BY</code> within your <code>OVER</code> clause. This is optional, though it is important for any ranking or cumulative functions. </p>
            <h4>Syntax</h4>
            <div class="fcnWrapperWide"><pre class="FcnSyntax" xml:space="preserve">ORDER&#160;BY expression
   [ ASC&#160;|&#160;DESC&#160;|&#160;USING&#160;<em>operator</em> ]<br /> &#160;&#160;[ NULLS&#160;FIRST&#160;|&#160;NULLS&#160;LAST ]
   [, ...]</pre>
            </div>
            <p class="spaceAbove">Some notes about the <code>ORDER&#160;BY</code>&#160;clause in an <code>OVER</code>&#160;clause:</p>
            <ul>
                <li>Ascending order (<code>ASC</code>)&#160;is the default ordering.</li>
                <li>If you specify <code>NULLS&#160;LAST</code>, then <code>NULL</code>&#160;values are returned last; this is the default when you use <code>ASC</code>&#160;order. </li>
                <li>If you specify <code>NULLS&#160;FIRST</code>, then <code>NULL</code>&#160;values are returned first; this is the default when you use <code>DESC</code>&#160;order. </li>
                <li>The <code>ORDER BY</code> clause in your <code>OVER</code>&#160;clause <em>does not</em> have to match the order in which the rows are output.</li>
                <li>You can only specify a <em>frame clause</em> if you include an <code>ORDER&#160;BY</code>&#160;clause in your <code>OVER</code> clause.</li>
            </ul>
            <h3 id="Window2">The Frame Clause</h3>
            <p>The optional frame clause defines which of the rows in the partition (the <code>frame</code>)&#160;should be evaluated by the window function. You can limit which rows in the partition are passed to the function in two ways:</p>
            <ul>
                <li>Specify a <code>ROWS</code> frame to limit the frame to a fixed number of rows from the partition that precede or follow the current row.</li>
                <li>Specify <code>RANGE</code>&#160;to only include rows in the frame whose evaluated value falls within a certain range of the current row's value. This is the default, and the current default range is <code>1</code>, which means that only rows whose value matches that of the current row are passed to the function.</li>
            </ul>
            <p>Some sources refer to the frame clause as the <em>Rows or Ranges</em> clause. If you omit this clause, the default is to include all rows </p>
            <p class="noteNote">Window frames can only be used when you include an <code>ORDER&#160;BY</code>&#160;clause within the <code>OVER</code>&#160;clause.</p>
            <h4>Syntax</h4>
            <p>This clause specifies two offsets: one determines the start of the window frame, and the other determines the end of the window frame.</p>
            <div class="fcnWrapperWide"><pre class="FcnSyntax" xml:space="preserve">[RANGE&#160;|&#160;ROWS] <em>frameStart</em> |
[RANGE&#160;|&#160;ROWS] BETWEEN&#160;<em>frameStart</em> AND&#160;<em>frameEnd</em></pre>
            </div>
            <div class="paramListNested">
                <p class="paramName"><code>RANGE</code>
                </p>
                <p class="paramDefnFirst">The frame includes rows whose values are within a specified range of the current row's value.</p>
                <p class="paramDefn">The range is determined by the <code>ORDER&#160;BY</code>&#160;column(s). Rows with identical values for their <code>ORDER&#160;BY</code>&#160;columns are referred to as <em>peer rows</em>.</p>
                <p class="paramName"><code>ROWS</code>
                </p>
                <p class="paramDefnFirst">The frame includes a fixed number of rows based on their position in the table relative to the current row.</p>
                <p class="paramName">frameStart</p>
                <p class="paramDefnFirst">Specifies the start of the frame.</p>
                <p class="paramDefn">For <code>ROWS</code>&#160;mode, you can specify:</p>
                <blockquote>
                    <div class="fcnWrapperWide"><pre class="FcnSyntax" xml:space="preserve">UNBOUNDED&#160;PRECEDING
| <span class="CodeItalicFont">value</span>&#160;PRECEDING
| CURRENT&#160;ROW
| <span class="CodeItalicFont">value</span>&#160;FOLLOWING</pre>
                    </div>
                    <div class="paramListNested">
                        <p class="paramName"><span class="CodeItalicFont">value</span>
                        </p>
                        <p class="paramDefnFirst">A non-negative integer value.</p>
                    </div>
                </blockquote>
                <p class="paramDefnFirst">For <code>RANGE</code>&#160;mode, you can only specify:</p>
                <blockquote>
                    <div class="fcnWrapperWide"><pre class="FcnSyntax" xml:space="preserve">CURRENT&#160;ROW
|&#160;UNBOUNDED&#160;FOLLOWING</pre>
                    </div>
                </blockquote>
                <p class="paramName">frameEnd</p>
                <p class="paramDefnFirst">Specifies the end of the frame. The default value is <code>CURRENT&#160;ROW</code>.</p>
                <p class="paramDefn">For <code>ROWS</code>&#160;mode, you can specify:</p>
                <blockquote>
                    <div class="fcnWrapperWide"><pre class="FcnSyntax" xml:space="preserve"><span class="CodeItalicFont">value</span>&#160;PRECEDING
| CURRENT&#160;ROW
| <span class="CodeItalicFont">value</span>&#160;FOLLOWING
|&#160;UNBOUNDED&#160;FOLLOWING</pre>
                    </div>
                    <div class="paramListNested">
                        <p class="paramName"><span class="CodeItalicFont">value</span>
                        </p>
                        <p class="paramDefnFirst">A non-negative integer value.</p>
                    </div>
                </blockquote>
                <p class="paramDefnFirst">For <code>RANGE</code>&#160;mode, you can only specify:</p>
                <blockquote>
                    <div class="fcnWrapperWide"><pre class="FcnSyntax" xml:space="preserve">CURRENT&#160;ROW
|&#160;UNBOUNDED&#160;FOLLOWING</pre>
                    </div>
                </blockquote>
            </div>
            <h4>Ranges and Rows</h4>
            <p class="body">Probably the easiest way to understand how <code>RANGE</code>&#160;and <code>ROWS</code>&#160;work is by way of some simple <code>OVER</code>&#160;clause examples:</p>
            <blockquote>
                <h5 id="Example">Example 1:</h5>
                <p class="body">This clause can be used to apply a window function to all rows in the partition from the top of the partition to the current row:</p><pre class="Example" xml:space="preserve">OVER&#160;(PARTITION&#160;BY&#160;customerID ORDER&#160;BY&#160;orderDate)</pre>
                <h5>Example 2:</h5>
                <p class="body">Both of these clauses specify the same set of rows as <a href="#Example" class="selected">Example 1:</a></p><pre class="Example" xml:space="preserve">OVER&#160;(PARTITION&#160;BY&#160;customerID ORDER&#160;BY&#160;orderDate UNBOUNDED&#160;PRECEDING preceding)

OVER&#160;(PARTITION&#160;BY&#160;customerID&#160;ORDER&#160;BY&#160;orderDate RANGE&#160;BETWEEN&#160;UNBOUNDED PRECEDING&#160;AND&#160;CURRENT&#160;ROW)</pre>
                <h5>Example 3:</h5>
                <p class="body">This clause can be used to apply a window function to the current row and the 3 preceding row's values in the partition:</p><pre class="Example" xml:space="preserve">OVER&#160;(PARTITION&#160;BY&#160;customerID ORDER&#160;BY&#160;orderDate ROWS&#160;3 preceding)</pre>
            </blockquote>
            <h4>FrameStart and FrameEnd</h4>
            <p>Some important notes about the frame clause:</p>
            <ul>
                <li><code>UNBOUNDED&#160;PRECEDING</code>&#160;means that the frame starts with the first row of the partition.</li>
                <li><code>UNBOUNDED&#160;FOLLOWING</code>&#160;means that the frame ends with the last row of the partition.</li>
                <li>You must specify the <span class="CodeItalicFont">frameStart</span> first and the <span class="CodeItalicFont">frameEnd</span> last within the frame clause.</li>
                <li>In <code>ROWS</code>&#160;mode, <code>CURRENT ROW</code>&#160;means that the frame starts or ends with the current row; in <code>RANGE</code>&#160;mode, <code>CURRENT ROW</code>&#160;means that the frame starts or ends with the current row's first or last peer in the <code>ORDER&#160;BY</code>&#160;ordering.</li>
                <li>
                    <p>The default <em>frameClause</em> is to include all values from the start of the partition through the current row:&#160;</p>
                    <div class="preWrapper"><pre class="Example" xml:space="preserve">RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW</pre>
                    </div>
                </li>
            </ul>
            <h4>Common Frame Clauses</h4>
            <p>When learning about window functions, you may find references to these specific frame clause types:</p>
            <table summary="Some common frame clause examples">
                <col />
                <col />
                <thead>
                    <tr>
                        <th>Frame Clause Type</th>
                        <th>Example</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td class="ItalicFont">Recycled</td>
                        <td class="CodeFont">BETWEEN&#160;UNBOUNDED&#160;PRECEDING&#160;AND&#160;UNBOUNDED&#160;FOLLOWING</td>
                    </tr>
                    <tr>
                        <td class="ItalicFont">Cumulative</td>
                        <td class="CodeFont">BETWEEN&#160;UNBOUNDED&#160;PRECEDING&#160;AND&#160;CURRENT&#160;ROW</td>
                    </tr>
                    <tr>
                        <td class="ItalicFont">Rolling</td>
                        <td class="CodeFont">BETWEEN&#160;2 PRECEDING&#160;AND&#160;2 FOLLOWING</td>
                    </tr>
                </tbody>
            </table>
            <h3>Examples</h3>
            <p>This is a simple example that doesn't use a frame clause:</p>
            <div class="opsStepsList">
                <ol class="boldFont">
                    <li>
                        <p class="topLevel">Rank each year within a player by the number of home runs hit by that player:</p>
                        <div class="preWrapperWide"><pre class="Example" xml:space="preserve">
RANK()&#160;OVER&#160;(PARTITION&#160;BY&#160;playerID&#160;ORDER&#160;BY&#160;H&#160;desc); </pre>
                        </div>
                    </li>
                </ol>
            </div>
            <p>Here are some examples of window functions using frame clauses:</p>
            <div class="opsStepsList">
                <ol class="boldFont">
                    <li>
                        <p class="topLevel">Compute the running sum of G&#160;for each player:</p>
                        <div class="preWrapperWide"><pre class="Example" xml:space="preserve">
SUM(G)&#160;OVER&#160;(PARTITION&#160;BY&#160;playerID&#160;ORDER&#160;BY&#160;yearID
  RANGE&#160;BETWEEN&#160;UNBOUNDED&#160;PRECEDING&#160;AND&#160;CURRENT&#160;ROW); </pre>
                        </div>
                    </li>
                    <li>
                        <p class="topLevel">Compute the career year:</p>
                        <div class="preWrapperWide"><pre class="Example" xml:space="preserve">
YearID - min(YEARID)&#160;OVER&#160;(PARTITION&#160;BY&#160;playerID
   RANGE&#160;BETWEEN&#160;UNBOUNDED&#160;PRECEDING&#160;AND&#160;UNBOUNDED&#160;FOLLOWING)&#160;+ 1; </pre>
                        </div>
                    </li>
                    <li>
                        <p class="topLevel">Compute a rolling average of games by player:</p>
                        <div class="preWrapperWide"><pre class="Example" xml:space="preserve">
AVG(G)&#160;OVER&#160;(PARTITION&#160;BY&#160;playerID&#160;ORDER&#160;BY&#160;yearID
   ROWS&#160;BETWEEN&#160;2 PRECEDING&#160;AND&#160;2 FOLLOWING); </pre>
                        </div>
                    </li>
                </ol>
            </div>
            <h2 id="The3">The Ranking Functions</h2>
            <p>A subset of our window functions are known as <em>ranking functions</em>:</p>
            <ul>
                <li class="CodeFont" value="1"><a href="sqlref_builtinfcns_denserank.html">DENSE_RANK</a><span class="bodyFont"> ranks each row in the result set. If values in the ranking column are the same, they receive the same rank. The next number in the ranking sequence is then used to rank the row or rows that follow, which means that <code>DENSE_RANK</code>&#160;always returns consecutive numbers.</span>
                </li>
                <li class="CodeFont" value="2"><a href="sqlref_builtinfcns_rank.html">RANK</a><span class="bodyFont"> ranks each row in the result set. If values in the ranking column are the same, they receive the same rank. However, the next number in the ranking sequence is then skipped, which means that <code>RANK</code>&#160;can return non-consecutive numbers.</span>
                </li>
                <li class="CodeFont" value="3"><a href="sqlref_builtinfcns_rownumber.html">ROW&#160;NUMBER</a><span class="bodyFont"> assigns a sequential number to each row in the result set.</span>
                </li>
            </ul>
            <p>All ranking functions <strong>must include</strong> an <code>ORDER&#160;BY</code>&#160;clause in the <code>OVER()</code>&#160;clause, since that is how they compute ranking values.</p>
            <h2>Window Function Restrictions</h2>
            <p>Because window functions are only allowed in <code><a href="sqlref_clauses_orderby.html">ORDER&#160;BY</a></code>&#160;clauses, and because window functions are computed after both <code>WHERE</code>&#160;and <code>HAVING</code>, you sometimes need to use subqueries with window functions to accomplish what seems like it could be done in a simpler query. </p>
            <p>For example, because you cannot use an <code>OVER</code>&#160;clause in a <code>WHERE</code>&#160;clause, a query like the following is not possible:</p>
            <div class="preWrapper"><pre class="Example" xml:space="preserve">SELECT&#160;*
FROM&#160;Batting
WHERE&#160;rank()&#160;OVER&#160;(PARTITION&#160;BY&#160;playerID&#160;ORDER&#160;BY&#160;G)&#160;= 1;</pre>
            </div>
            <p>And because <code>WHERE</code> and <code>HAVING</code>&#160;are computed before the windowing functions, this won't work either:</p>
            <div class="preWrapper"><pre class="Example" xml:space="preserve">SELECT&#160;playerID, rank()&#160;OVER&#160;(PARTITION&#160;BY&#160;playerID&#160;ORDER&#160;BY&#160;G) as player_rank FROM&#160;Batting
WHERE&#160;player_rank&#160;= 1;</pre>
            </div>
            <p>Instead, you need to use a subquery:</p>
            <div class="preWrapper"><pre class="Example" xml:space="preserve">SELECT&#160;*
FROM&#160;(
   SELECT&#160;playerID, G, rank()&#160;OVER&#160;(PARTITION&#160;BY&#160;playerID&#160;ORDER&#160;BY&#160;G) as "pos"
   FROM&#160;Batting
)&#160;tmp
WHERE&#160;"pos" = 1;</pre>
            </div>
            <p>And note that the above subquery will add a rank column to the original columns,</p>
            <h2 id="IncludedFcns">Window Functions Included in This Release</h2>
            <p>Splice Machine is currently expanding the set of SQL&#160;functions already able to take advantage of windowing functionality.</p>
            <p>The <code><a href="sqlref_clauses_over.html">OVER</a></code>&#160;clause topic in our <em>SQL&#160;Reference</em> completes the complete reference information for <code>OVER</code>.</p>
            <p> Here is a list of the functions that currently support windowing:</p>
            <ul>
                <li class="CodeFont" value="1"><a href="sqlref_builtinfcns_avg.html">AVG</a>
                </li>
                <li class="CodeFont" value="2"><a href="sqlref_builtinfcns_count.html">COUNT</a>
                </li>
                <li class="CodeFont" value="3"><a href="sqlref_builtinfcns_denserank.html">DENSE_RANK</a>
                </li>
                <li class="CodeFont" value="4"><a href="sqlref_builtinfcns_firstvalue.html">FIRST_VALUE</a>
                </li>
                <li class="CodeFont" value="5"><a href="sqlref_builtinfcns_lag.html">LAG</a>
                </li>
                <li class="CodeFont" value="6"><a href="sqlref_builtinfcns_lastvalue.html">LAST_VALUE</a>
                </li>
                <li class="CodeFont" value="7"><a href="sqlref_builtinfcns_lead.html">LEAD</a>
                </li>
                <li class="CodeFont" value="8"><a href="sqlref_builtinfcns_max.html">MAX</a>
                </li>
                <li class="CodeFont" value="9"><a href="sqlref_builtinfcns_min.html">MIN</a>
                </li>
                <li class="CodeFont" value="10"><a href="sqlref_builtinfcns_rank.html">RANK</a>
                </li>
                <li class="CodeFont" value="11"><a href="sqlref_builtinfcns_rownumber.html">ROW&#160;NUMBER</a>
                </li>
                <li class="CodeFont" value="12"><a href="sqlref_builtinfcns_sum.html">SUM</a>
                </li>
            </ul>
            <h2 id="ForMoreInfo">Additional Information</h2>
            <p>There are numerous articles about window functions that you can find online. Here are a few you might find valuable:</p>
            <ul>
                <li>The <a href="https://www.simple-talk.com/sql/learn-sql-server/window-functions-in-sql-server/"  target="_blank">simple talk articles from Red Gate</a> about window functions are probably the most straightforward and comprehensive descriptions of window functions.</li>
                <li>This <a href="http://www.oracle.com/technetwork/issue-archive/2013/13-mar/o23sql-1906475.html"  target="_blank">Oracle Technology Network article</a> provides an excellent technical introduction.</li>
                <li>This <a href="http://www.postgresql.org/docs/9.1/static/tutorial-window.html"  target="_blank">PostgreSQL page</a> introduces their version of window functions and links to other pages.</li>
                <li>This <a href="https://wiki.postgresql.org/wiki/SQL2008_windowing_queries"  target="_blank">PostgreSQL&#160;wiki page</a> about SQL&#160;windowing queries page provides a succinct explanation of why windowing functions are used, and includes several useful examples.</li>
                <li>The <a href="http://en.wikipedia.org/wiki/Select_(SQL)"  target="_blank">Wikipedia SQL&#160;SELECT</a>&#160;page contains descriptions of specific window functions and links to other pages.</li>
            </ul>
        </div>
	</section>
